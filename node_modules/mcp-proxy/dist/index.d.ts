import { JSONRPCMessage, ServerCapabilities } from '@modelcontextprotocol/sdk/types.js';
import { EventStore } from '@modelcontextprotocol/sdk/server/streamableHttp.js';
import { Server } from '@modelcontextprotocol/sdk/server/index.js';
import { Client } from '@modelcontextprotocol/sdk/client/index.js';
import http from 'http';
import { Transport } from '@modelcontextprotocol/sdk/shared/transport.js';

/**
 * This is a copy of the InMemoryEventStore from the typescript-sdk
 * https://github.com/modelcontextprotocol/typescript-sdk/blob/main/src/inMemoryEventStore.ts
 */

/**
 * Simple in-memory implementation of the EventStore interface for resumability
 * This is primarily intended for examples and testing, not for production use
 * where a persistent storage solution would be more appropriate.
 */
declare class InMemoryEventStore implements EventStore {
    private events;
    /**
     * Generates a unique event ID for a given stream ID
     */
    private generateEventId;
    /**
     * Extracts the stream ID from an event ID
     */
    private getStreamIdFromEventId;
    /**
     * Stores an event with a generated event ID
     * Implements EventStore.storeEvent
     */
    storeEvent(streamId: string, message: JSONRPCMessage): Promise<string>;
    /**
     * Replays events that occurred after a specific event ID
     * Implements EventStore.replayEventsAfter
     */
    replayEventsAfter(lastEventId: string, { send, }: {
        send: (eventId: string, message: JSONRPCMessage) => Promise<void>;
    }): Promise<string>;
}

declare const proxyServer: ({ server, client, serverCapabilities, }: {
    server: Server;
    client: Client;
    serverCapabilities: ServerCapabilities;
}) => Promise<void>;

type SSEServer$1 = {
    close: () => Promise<void>;
};
type ServerLike$1 = {
    connect: Server["connect"];
    close: Server["close"];
};
declare const startHTTPStreamServer: <T extends ServerLike$1>({ port, createServer, endpoint, eventStore, onConnect, onClose, onUnhandledRequest, }: {
    port: number;
    endpoint: string;
    createServer: (request: http.IncomingMessage) => Promise<T>;
    eventStore?: EventStore;
    onConnect?: (server: T) => void;
    onClose?: (server: T) => void;
    onUnhandledRequest?: (req: http.IncomingMessage, res: http.ServerResponse) => Promise<void>;
}) => Promise<SSEServer$1>;

type SSEServer = {
    close: () => Promise<void>;
};
type ServerLike = {
    connect: Server["connect"];
    close: Server["close"];
};
declare const startSSEServer: <T extends ServerLike>({ port, createServer, endpoint, onConnect, onClose, onUnhandledRequest, }: {
    port: number;
    endpoint: string;
    createServer: (request: http.IncomingMessage) => Promise<T>;
    onConnect?: (server: T) => void;
    onClose?: (server: T) => void;
    onUnhandledRequest?: (req: http.IncomingMessage, res: http.ServerResponse) => Promise<void>;
}) => Promise<SSEServer>;

type TransportEvent = {
    type: "close";
} | {
    type: "onclose";
} | {
    type: "onerror";
    error: Error;
} | {
    type: "onmessage";
    message: JSONRPCMessage;
} | {
    type: "send";
    message: JSONRPCMessage;
} | {
    type: "start";
};
declare const tapTransport: (transport: Transport, eventHandler: (event: TransportEvent) => void) => Transport;

export { InMemoryEventStore, proxyServer, startHTTPStreamServer, startSSEServer, tapTransport };
